package generator;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;
import io.vavr.Tuple;
import io.vavr.collection.Map;
import io.vavr.collection.Multimap;
import io.vavr.control.Either;
import java.io.File;
import java.io.IOException;
import java.util.stream.Collectors;
import javax.lang.model.element.Modifier;
import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.Test;
import tools.jackson.core.type.TypeReference;

import static generator.utils.Initializer.initMapper;
import static generator.utils.Initializer.initValue;
import static generator.utils.Initializer.publicVavrClass;
import static generator.utils.Serializer.expectedJson;

/**
 * @author Ruslan Sennov, Grzegorz Piwowarek</a>
 */
public class ParameterizedPojo {

    public static void main(String[] args) throws IOException {
        java.util.Map<String, Object> cases = new java.util.HashMap<>();
        cases.put("TupleOfString", Tuple.of("A", "B"));
        cases.put("TupleOfTuple", Tuple.of("A", Tuple.of("A", "B")));
        generate(cases);
    }

    static void generate(java.util.Map<String, Object> cases) throws IOException {

        TypeSpec.Builder pojoTest = TypeSpec.classBuilder("ParameterizedPojoTest")
            .addJavadoc("generated by {@link generator.Generator} - don't edit manually\n")
            .addModifiers(Modifier.PUBLIC);
        initMapper(pojoTest, "MAPPER");

        cases.forEach((k, v) -> addCase(pojoTest, k, v));

        JavaFile javaFile = JavaFile.builder("io.vavr.jackson.generated", pojoTest.build())
            .indent("    ")
            .skipJavaLangImports(true)
            .build();

        javaFile.writeTo(new File("src/test/java"));
    }

    private static final java.util.Set<Class<?>> generated = new java.util.HashSet<>();

    private static void addCase(TypeSpec.Builder builder, String pojoName, Object value) {
        Class<?> clz = publicVavrClass(value.getClass());
        if (!generated.contains(clz)) {
            addPojo(builder, clz, getArity(value, clz));
            generated.add(clz);
        }
        addCase(builder, pojoName, value, clz.getSimpleName());
    }

    private static int getArity(Object value, Class<?> clz) {
        if (Tuple.class.isAssignableFrom(clz)) {
            return ((Tuple) value).arity();
        } else if (Map.class.isAssignableFrom(clz) || Multimap.class.isAssignableFrom(clz) || Either.class.isAssignableFrom(clz)) {
            return 2;
        } else {
            return 1;
        }
    }

    private static void addCase(TypeSpec.Builder builder, String pojoName, Object value, String clz) {
        MethodSpec.Builder testBuilder = MethodSpec.methodBuilder("shouldHandle" + pojoName).addAnnotation(Test.class);
        TypeName valueTypeName = initValue(testBuilder, "src", value);
        String generics = ((ParameterizedTypeName) valueTypeName).typeArguments.stream()
            .map(TypeName::toString)
            .collect(Collectors.joining(", "));
        MethodSpec testSpec = testBuilder
            .addStatement("var json = MAPPER.writeValueAsString(new Parameterized$LPojo<>(src))", clz)
            .addStatement("$T.assertThat(json).isEqualTo($S)", ClassName.get(Assertions.class), "{\"value\":" + expectedJson(value, 0) + "}")
            .addStatement("Parameterized$LPojo<$L> restored =\n" +
                          "MAPPER.readValue(json, new $T<>(){})", clz, generics, ClassName.get(TypeReference.class))
            .addStatement("$T.assertThat(restored.getValue()).isEqualTo(src)", ClassName.get(Assertions.class))
            .build();
        builder.addMethod(testSpec);
    }

    private static void addPojo(TypeSpec.Builder builder, Class<?> clz, int arity) {
        String pojoName = "Parameterized" + clz.getSimpleName() + "Pojo";
        TypeSpec.Builder pojoSpec = TypeSpec.classBuilder(pojoName)
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);
        TypeName[] types = new TypeName[arity];
        for (int i = 1; i <= arity; i++) {
            types[i - 1] = TypeVariableName.get("T" + i);
            pojoSpec.addTypeVariable(TypeVariableName.get("T" + i));
        }
        TypeName type = ParameterizedTypeName.get(ClassName.get(clz), types);
        pojoSpec
            .addField(FieldSpec.builder(type, "v", Modifier.PRIVATE).build())
            .addMethod(MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .build())
            .addMethod(MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addParameter(ParameterSpec.builder(type, "v").build())
                .addStatement("this.v = v")
                .build())
            .addMethod(MethodSpec.methodBuilder("getValue")
                .addModifiers(Modifier.PUBLIC)
                .returns(type)
                .addStatement("return v")
                .build())
            .addMethod(MethodSpec.methodBuilder("setValue")
                .addModifiers(Modifier.PUBLIC)
                .returns(ParameterizedTypeName.get(ClassName.get("", pojoName), types))
                .addParameter(ParameterSpec.builder(type, "v").build())
                .addStatement("this.v = v")
                .addStatement("return this")
                .build())
            .build();

        builder.addType(pojoSpec.build());
    }
}
