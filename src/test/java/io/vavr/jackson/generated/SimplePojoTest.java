package io.vavr.jackson.generated;

import io.vavr.Lazy;
import io.vavr.Tuple;
import io.vavr.Tuple1;
import io.vavr.Tuple2;
import io.vavr.Tuple3;
import io.vavr.Tuple4;
import io.vavr.Tuple5;
import io.vavr.Tuple6;
import io.vavr.Tuple7;
import io.vavr.Tuple8;
import io.vavr.collection.Array;
import io.vavr.collection.HashMap;
import io.vavr.collection.HashMultimap;
import io.vavr.collection.HashSet;
import io.vavr.collection.LinkedHashMap;
import io.vavr.collection.LinkedHashMultimap;
import io.vavr.collection.LinkedHashSet;
import io.vavr.collection.List;
import io.vavr.collection.PriorityQueue;
import io.vavr.collection.Queue;
import io.vavr.collection.Stream;
import io.vavr.collection.TreeMap;
import io.vavr.collection.TreeMultimap;
import io.vavr.collection.TreeSet;
import io.vavr.collection.Vector;
import io.vavr.control.Either;
import io.vavr.control.Option;
import io.vavr.jackson.datatype.VavrModule;
import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.Test;
import tools.jackson.databind.ObjectMapper;
import tools.jackson.databind.json.JsonMapper;

/**
 * generated by {@link generator.Generator} - don't edit manually
 */
public class SimplePojoTest {
    private static final VavrModule MAPPER_MODULE = new VavrModule();

    private static final ObjectMapper MAPPER = JsonMapper.builder().addModule(MAPPER_MODULE).build();

    @Test
    void shouldHandleTuple1OfString() {
        var src0 = "A";
        Tuple1<String> src = Tuple.of(src0);
        var json = MAPPER.writeValueAsString(new Tuple1OfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\"]}");
        Tuple1OfString restored = MAPPER.readValue(json, Tuple1OfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple1OfTuple() {
        var src00 = "B";
        Tuple1<String> src0 = Tuple.of(src00);
        Tuple1<Tuple1<String>> src = Tuple.of(src0);
        var json = MAPPER.writeValueAsString(new Tuple1OfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[[\"B\"]]}");
        Tuple1OfTuple restored = MAPPER.readValue(json, Tuple1OfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple2OfString() {
        var src0 = "A";
        var src1 = "B";
        Tuple2<String, String> src = Tuple.of(src0, src1);
        var json = MAPPER.writeValueAsString(new Tuple2OfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\"]}");
        Tuple2OfString restored = MAPPER.readValue(json, Tuple2OfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple2OfTuple() {
        var src0 = "A";
        var src10 = "B";
        var src11 = "C";
        Tuple2<String, String> src1 = Tuple.of(src10, src11);
        Tuple2<String, Tuple2<String, String>> src = Tuple.of(src0, src1);
        var json = MAPPER.writeValueAsString(new Tuple2OfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",[\"B\",\"C\"]]}");
        Tuple2OfTuple restored = MAPPER.readValue(json, Tuple2OfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple3OfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        Tuple3<String, String, String> src = Tuple.of(src0, src1, src2);
        var json = MAPPER.writeValueAsString(new Tuple3OfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\"]}");
        Tuple3OfString restored = MAPPER.readValue(json, Tuple3OfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple3OfTuple() {
        var src0 = "A";
        var src10 = "B";
        var src11 = "C";
        Tuple2<String, String> src1 = Tuple.of(src10, src11);
        var src20 = "D";
        var src21 = "E";
        Tuple2<String, String> src2 = Tuple.of(src20, src21);
        Tuple3<String, Tuple2<String, String>, Tuple2<String, String>> src = Tuple.of(src0, src1, src2);
        var json = MAPPER.writeValueAsString(new Tuple3OfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",[\"B\",\"C\"],[\"D\",\"E\"]]}");
        Tuple3OfTuple restored = MAPPER.readValue(json, Tuple3OfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple4OfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        var src3 = "D";
        Tuple4<String, String, String, String> src = Tuple.of(src0, src1, src2, src3);
        var json = MAPPER.writeValueAsString(new Tuple4OfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\",\"D\"]}");
        Tuple4OfString restored = MAPPER.readValue(json, Tuple4OfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple4OfTuple() {
        var src0 = "A";
        var src10 = "B";
        var src11 = "C";
        Tuple2<String, String> src1 = Tuple.of(src10, src11);
        var src20 = "D";
        var src21 = "E";
        Tuple2<String, String> src2 = Tuple.of(src20, src21);
        var src30 = "F";
        var src31 = "1";
        Tuple2<String, String> src3 = Tuple.of(src30, src31);
        Tuple4<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>> src = Tuple.of(src0, src1, src2, src3);
        var json = MAPPER.writeValueAsString(new Tuple4OfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",[\"B\",\"C\"],[\"D\",\"E\"],[\"F\",\"1\"]]}");
        Tuple4OfTuple restored = MAPPER.readValue(json, Tuple4OfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple5OfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        var src3 = "D";
        var src4 = "E";
        Tuple5<String, String, String, String, String> src = Tuple.of(src0, src1, src2, src3, src4);
        var json = MAPPER.writeValueAsString(new Tuple5OfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\",\"D\",\"E\"]}");
        Tuple5OfString restored = MAPPER.readValue(json, Tuple5OfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple5OfTuple() {
        var src0 = "A";
        var src10 = "B";
        var src11 = "C";
        Tuple2<String, String> src1 = Tuple.of(src10, src11);
        var src20 = "D";
        var src21 = "E";
        Tuple2<String, String> src2 = Tuple.of(src20, src21);
        var src30 = "F";
        var src31 = "1";
        Tuple2<String, String> src3 = Tuple.of(src30, src31);
        var src4 = "A";
        Tuple5<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String> src = Tuple.of(src0, src1, src2, src3, src4);
        var json = MAPPER.writeValueAsString(new Tuple5OfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",[\"B\",\"C\"],[\"D\",\"E\"],[\"F\",\"1\"],\"A\"]}");
        Tuple5OfTuple restored = MAPPER.readValue(json, Tuple5OfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple6OfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        var src3 = "D";
        var src4 = "E";
        var src5 = "F";
        Tuple6<String, String, String, String, String, String> src = Tuple.of(src0, src1, src2, src3, src4, src5);
        var json = MAPPER.writeValueAsString(new Tuple6OfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]}");
        Tuple6OfString restored = MAPPER.readValue(json, Tuple6OfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple6OfTuple() {
        var src0 = "A";
        var src10 = "B";
        var src11 = "C";
        Tuple2<String, String> src1 = Tuple.of(src10, src11);
        var src20 = "D";
        var src21 = "E";
        Tuple2<String, String> src2 = Tuple.of(src20, src21);
        var src30 = "F";
        var src31 = "1";
        Tuple2<String, String> src3 = Tuple.of(src30, src31);
        var src4 = "A";
        var src50 = "B";
        var src51 = "C";
        Tuple2<String, String> src5 = Tuple.of(src50, src51);
        Tuple6<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String, Tuple2<String, String>> src = Tuple.of(src0, src1, src2, src3, src4, src5);
        var json = MAPPER.writeValueAsString(new Tuple6OfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",[\"B\",\"C\"],[\"D\",\"E\"],[\"F\",\"1\"],\"A\",[\"B\",\"C\"]]}");
        Tuple6OfTuple restored = MAPPER.readValue(json, Tuple6OfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple7OfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        var src3 = "D";
        var src4 = "E";
        var src5 = "F";
        var src6 = "1";
        Tuple7<String, String, String, String, String, String, String> src = Tuple.of(src0, src1, src2, src3, src4, src5, src6);
        var json = MAPPER.writeValueAsString(new Tuple7OfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"1\"]}");
        Tuple7OfString restored = MAPPER.readValue(json, Tuple7OfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple7OfTuple() {
        var src0 = "A";
        var src10 = "B";
        var src11 = "C";
        Tuple2<String, String> src1 = Tuple.of(src10, src11);
        var src20 = "D";
        var src21 = "E";
        Tuple2<String, String> src2 = Tuple.of(src20, src21);
        var src30 = "F";
        var src31 = "1";
        Tuple2<String, String> src3 = Tuple.of(src30, src31);
        var src4 = "A";
        var src50 = "B";
        var src51 = "C";
        Tuple2<String, String> src5 = Tuple.of(src50, src51);
        var src60 = "D";
        var src61 = "E";
        Tuple2<String, String> src6 = Tuple.of(src60, src61);
        Tuple7<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String, Tuple2<String, String>, Tuple2<String, String>> src = Tuple.of(src0, src1, src2, src3, src4, src5, src6);
        var json = MAPPER.writeValueAsString(new Tuple7OfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",[\"B\",\"C\"],[\"D\",\"E\"],[\"F\",\"1\"],\"A\",[\"B\",\"C\"],[\"D\",\"E\"]]}");
        Tuple7OfTuple restored = MAPPER.readValue(json, Tuple7OfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple8OfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        var src3 = "D";
        var src4 = "E";
        var src5 = "F";
        var src6 = "1";
        var src7 = "2";
        Tuple8<String, String, String, String, String, String, String, String> src = Tuple.of(src0, src1, src2, src3, src4, src5, src6, src7);
        var json = MAPPER.writeValueAsString(new Tuple8OfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"1\",\"2\"]}");
        Tuple8OfString restored = MAPPER.readValue(json, Tuple8OfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTuple8OfTuple() {
        var src0 = "A";
        var src10 = "B";
        var src11 = "C";
        Tuple2<String, String> src1 = Tuple.of(src10, src11);
        var src20 = "D";
        var src21 = "E";
        Tuple2<String, String> src2 = Tuple.of(src20, src21);
        var src30 = "F";
        var src31 = "1";
        Tuple2<String, String> src3 = Tuple.of(src30, src31);
        var src4 = "A";
        var src50 = "B";
        var src51 = "C";
        Tuple2<String, String> src5 = Tuple.of(src50, src51);
        var src60 = "D";
        var src61 = "E";
        Tuple2<String, String> src6 = Tuple.of(src60, src61);
        var src70 = "F";
        var src71 = "1";
        Tuple2<String, String> src7 = Tuple.of(src70, src71);
        Tuple8<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>> src = Tuple.of(src0, src1, src2, src3, src4, src5, src6, src7);
        var json = MAPPER.writeValueAsString(new Tuple8OfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",[\"B\",\"C\"],[\"D\",\"E\"],[\"F\",\"1\"],\"A\",[\"B\",\"C\"],[\"D\",\"E\"],[\"F\",\"1\"]]}");
        Tuple8OfTuple restored = MAPPER.readValue(json, Tuple8OfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleArrayOfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        Array<String> src = Array.of(src0, src1, src2);
        var json = MAPPER.writeValueAsString(new ArrayOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\"]}");
        ArrayOfString restored = MAPPER.readValue(json, ArrayOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleArrayOfTuple() {
        var src00 = "A";
        var src01 = "B";
        Tuple2<String, String> src0 = Tuple.of(src00, src01);
        Array<Tuple2<String, String>> src = Array.of(src0);
        var json = MAPPER.writeValueAsString(new ArrayOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[[\"A\",\"B\"]]}");
        ArrayOfTuple restored = MAPPER.readValue(json, ArrayOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleListOfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        List<String> src = List.of(src0, src1, src2);
        var json = MAPPER.writeValueAsString(new ListOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\"]}");
        ListOfString restored = MAPPER.readValue(json, ListOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleListOfTuple() {
        var src00 = "A";
        var src01 = "B";
        Tuple2<String, String> src0 = Tuple.of(src00, src01);
        List<Tuple2<String, String>> src = List.of(src0);
        var json = MAPPER.writeValueAsString(new ListOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[[\"A\",\"B\"]]}");
        ListOfTuple restored = MAPPER.readValue(json, ListOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleQueueOfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        Queue<String> src = Queue.of(src0, src1, src2);
        var json = MAPPER.writeValueAsString(new QueueOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\"]}");
        QueueOfString restored = MAPPER.readValue(json, QueueOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleQueueOfTuple() {
        var src00 = "A";
        var src01 = "B";
        Tuple2<String, String> src0 = Tuple.of(src00, src01);
        Queue<Tuple2<String, String>> src = Queue.of(src0);
        var json = MAPPER.writeValueAsString(new QueueOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[[\"A\",\"B\"]]}");
        QueueOfTuple restored = MAPPER.readValue(json, QueueOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleStreamOfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        Stream<String> src = Stream.of(src0, src1, src2);
        var json = MAPPER.writeValueAsString(new StreamOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\"]}");
        StreamOfString restored = MAPPER.readValue(json, StreamOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleStreamOfTuple() {
        var src00 = "A";
        var src01 = "B";
        Tuple2<String, String> src0 = Tuple.of(src00, src01);
        Stream<Tuple2<String, String>> src = Stream.of(src0);
        var json = MAPPER.writeValueAsString(new StreamOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[[\"A\",\"B\"]]}");
        StreamOfTuple restored = MAPPER.readValue(json, StreamOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleVectorOfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        Vector<String> src = Vector.of(src0, src1, src2);
        var json = MAPPER.writeValueAsString(new VectorOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\"]}");
        VectorOfString restored = MAPPER.readValue(json, VectorOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleVectorOfTuple() {
        var src00 = "A";
        var src01 = "B";
        Tuple2<String, String> src0 = Tuple.of(src00, src01);
        Vector<Tuple2<String, String>> src = Vector.of(src0);
        var json = MAPPER.writeValueAsString(new VectorOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[[\"A\",\"B\"]]}");
        VectorOfTuple restored = MAPPER.readValue(json, VectorOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandlePriorityQueueOfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        PriorityQueue<String> src = PriorityQueue.of(src0, src1, src2);
        var json = MAPPER.writeValueAsString(new PriorityQueueOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\"]}");
        PriorityQueueOfString restored = MAPPER.readValue(json, PriorityQueueOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleHashSetOfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        HashSet<String> src = HashSet.of(src0, src1, src2);
        var json = MAPPER.writeValueAsString(new HashSetOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\"]}");
        HashSetOfString restored = MAPPER.readValue(json, HashSetOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleHashSetOfTuple() {
        var src00 = "A";
        var src01 = "B";
        Tuple2<String, String> src0 = Tuple.of(src00, src01);
        HashSet<Tuple2<String, String>> src = HashSet.of(src0);
        var json = MAPPER.writeValueAsString(new HashSetOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[[\"A\",\"B\"]]}");
        HashSetOfTuple restored = MAPPER.readValue(json, HashSetOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleLinkedHashSetOfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        LinkedHashSet<String> src = LinkedHashSet.of(src0, src1, src2);
        var json = MAPPER.writeValueAsString(new LinkedHashSetOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\"]}");
        LinkedHashSetOfString restored = MAPPER.readValue(json, LinkedHashSetOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleLinkedHashSetOfTuple() {
        var src00 = "A";
        var src01 = "B";
        Tuple2<String, String> src0 = Tuple.of(src00, src01);
        LinkedHashSet<Tuple2<String, String>> src = LinkedHashSet.of(src0);
        var json = MAPPER.writeValueAsString(new LinkedHashSetOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[[\"A\",\"B\"]]}");
        LinkedHashSetOfTuple restored = MAPPER.readValue(json, LinkedHashSetOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTreeSetOfString() {
        var src0 = "A";
        var src1 = "B";
        var src2 = "C";
        TreeSet<String> src = TreeSet.of(src0, src1, src2);
        var json = MAPPER.writeValueAsString(new TreeSetOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\",\"C\"]}");
        TreeSetOfString restored = MAPPER.readValue(json, TreeSetOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleHashMapOfString() {
        var src00 = 1;
        var src01 = "A";
        Tuple2<Integer, String> src0 = Tuple.of(src00, src01);
        HashMap<Integer, String> src = HashMap.ofEntries(src0);
        var json = MAPPER.writeValueAsString(new HashMapOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":{\"1\":\"A\"}}");
        HashMapOfString restored = MAPPER.readValue(json, HashMapOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleHashMapOfTuple() {
        var src00 = 1;
        var src010 = "A";
        var src011 = "B";
        Tuple2<String, String> src01 = Tuple.of(src010, src011);
        Tuple2<Integer, Tuple2<String, String>> src0 = Tuple.of(src00, src01);
        HashMap<Integer, Tuple2<String, String>> src = HashMap.ofEntries(src0);
        var json = MAPPER.writeValueAsString(new HashMapOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":{\"1\":[\"A\",\"B\"]}}");
        HashMapOfTuple restored = MAPPER.readValue(json, HashMapOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleLinkedHashMapOfString() {
        var src00 = 1;
        var src01 = "A";
        Tuple2<Integer, String> src0 = Tuple.of(src00, src01);
        LinkedHashMap<Integer, String> src = LinkedHashMap.ofEntries(src0);
        var json = MAPPER.writeValueAsString(new LinkedHashMapOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":{\"1\":\"A\"}}");
        LinkedHashMapOfString restored = MAPPER.readValue(json, LinkedHashMapOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleLinkedHashMapOfTuple() {
        var src00 = 1;
        var src010 = "A";
        var src011 = "B";
        Tuple2<String, String> src01 = Tuple.of(src010, src011);
        Tuple2<Integer, Tuple2<String, String>> src0 = Tuple.of(src00, src01);
        LinkedHashMap<Integer, Tuple2<String, String>> src = LinkedHashMap.ofEntries(src0);
        var json = MAPPER.writeValueAsString(new LinkedHashMapOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":{\"1\":[\"A\",\"B\"]}}");
        LinkedHashMapOfTuple restored = MAPPER.readValue(json, LinkedHashMapOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTreeMapOfString() {
        var src00 = 1;
        var src01 = "A";
        Tuple2<Integer, String> src0 = Tuple.of(src00, src01);
        TreeMap<Integer, String> src = TreeMap.ofEntries(src0);
        var json = MAPPER.writeValueAsString(new TreeMapOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":{\"1\":\"A\"}}");
        TreeMapOfString restored = MAPPER.readValue(json, TreeMapOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTreeMapOfTuple() {
        var src00 = 1;
        var src010 = "A";
        var src011 = "B";
        Tuple2<String, String> src01 = Tuple.of(src010, src011);
        Tuple2<Integer, Tuple2<String, String>> src0 = Tuple.of(src00, src01);
        TreeMap<Integer, Tuple2<String, String>> src = TreeMap.ofEntries(src0);
        var json = MAPPER.writeValueAsString(new TreeMapOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":{\"1\":[\"A\",\"B\"]}}");
        TreeMapOfTuple restored = MAPPER.readValue(json, TreeMapOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleHashMultimapOfSeqString() {
        var src00 = "A";
        var src01 = "B";
        Tuple2<String, String> src0 = Tuple.of(src00, src01);
        var src10 = "A";
        var src11 = "C";
        Tuple2<String, String> src1 = Tuple.of(src10, src11);
        HashMultimap<String, String> src = HashMultimap.withSeq().ofEntries(src0, src1);
        var json = MAPPER.writeValueAsString(new HashMultimapOfSeqString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":{\"A\":[\"B\",\"C\"]}}");
        HashMultimapOfSeqString restored = MAPPER.readValue(json, HashMultimapOfSeqString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleHashMultimapOfSeqTuple() {
        var src00 = "A";
        var src010 = "A";
        var src011 = "B";
        Tuple2<String, String> src01 = Tuple.of(src010, src011);
        Tuple2<String, Tuple2<String, String>> src0 = Tuple.of(src00, src01);
        var src10 = "A";
        var src110 = "C";
        var src111 = "D";
        Tuple2<String, String> src11 = Tuple.of(src110, src111);
        Tuple2<String, Tuple2<String, String>> src1 = Tuple.of(src10, src11);
        HashMultimap<String, Tuple2<String, String>> src = HashMultimap.withSeq().ofEntries(src0, src1);
        var json = MAPPER.writeValueAsString(new HashMultimapOfSeqTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":{\"A\":[[\"A\",\"B\"],[\"C\",\"D\"]]}}");
        HashMultimapOfSeqTuple restored = MAPPER.readValue(json, HashMultimapOfSeqTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleLinkedHashMultimapOfSeqString() {
        var src00 = "A";
        var src01 = "B";
        Tuple2<String, String> src0 = Tuple.of(src00, src01);
        var src10 = "A";
        var src11 = "C";
        Tuple2<String, String> src1 = Tuple.of(src10, src11);
        LinkedHashMultimap<String, String> src = LinkedHashMultimap.withSeq().ofEntries(src0, src1);
        var json = MAPPER.writeValueAsString(new LinkedHashMultimapOfSeqString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":{\"A\":[\"B\",\"C\"]}}");
        LinkedHashMultimapOfSeqString restored = MAPPER.readValue(json, LinkedHashMultimapOfSeqString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleLinkedHashMultimapOfSeqTuple() {
        var src00 = "A";
        var src010 = "A";
        var src011 = "B";
        Tuple2<String, String> src01 = Tuple.of(src010, src011);
        Tuple2<String, Tuple2<String, String>> src0 = Tuple.of(src00, src01);
        var src10 = "A";
        var src110 = "C";
        var src111 = "D";
        Tuple2<String, String> src11 = Tuple.of(src110, src111);
        Tuple2<String, Tuple2<String, String>> src1 = Tuple.of(src10, src11);
        LinkedHashMultimap<String, Tuple2<String, String>> src = LinkedHashMultimap.withSeq().ofEntries(src0, src1);
        var json = MAPPER.writeValueAsString(new LinkedHashMultimapOfSeqTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":{\"A\":[[\"A\",\"B\"],[\"C\",\"D\"]]}}");
        LinkedHashMultimapOfSeqTuple restored = MAPPER.readValue(json, LinkedHashMultimapOfSeqTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTreeMultimapOfSeqString() {
        var src00 = "A";
        var src01 = "B";
        Tuple2<String, String> src0 = Tuple.of(src00, src01);
        var src10 = "A";
        var src11 = "C";
        Tuple2<String, String> src1 = Tuple.of(src10, src11);
        TreeMultimap<String, String> src = TreeMultimap.withSet().ofEntries(src0, src1);
        var json = MAPPER.writeValueAsString(new TreeMultimapOfSeqString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":{\"A\":[\"B\",\"C\"]}}");
        TreeMultimapOfSeqString restored = MAPPER.readValue(json, TreeMultimapOfSeqString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleTreeMultimapOfSeqTuple() {
        var src00 = "A";
        var src010 = "A";
        var src011 = "B";
        Tuple2<String, String> src01 = Tuple.of(src010, src011);
        Tuple2<String, Tuple2<String, String>> src0 = Tuple.of(src00, src01);
        var src10 = "A";
        var src110 = "C";
        var src111 = "D";
        Tuple2<String, String> src11 = Tuple.of(src110, src111);
        Tuple2<String, Tuple2<String, String>> src1 = Tuple.of(src10, src11);
        TreeMultimap<String, Tuple2<String, String>> src = TreeMultimap.withSet().ofEntries(src0, src1);
        var json = MAPPER.writeValueAsString(new TreeMultimapOfSeqTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":{\"A\":[[\"A\",\"B\"],[\"C\",\"D\"]]}}");
        TreeMultimapOfSeqTuple restored = MAPPER.readValue(json, TreeMultimapOfSeqTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleOptionOfString() {
        var src0 = "A";
        Option<String> src = Option.of(src0);
        var json = MAPPER.writeValueAsString(new OptionOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":\"A\"}");
        OptionOfString restored = MAPPER.readValue(json, OptionOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleOptionOfTuple() {
        var src00 = "A";
        var src01 = "B";
        Tuple2<String, String> src0 = Tuple.of(src00, src01);
        Option<Tuple2<String, String>> src = Option.of(src0);
        var json = MAPPER.writeValueAsString(new OptionOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\"]}");
        OptionOfTuple restored = MAPPER.readValue(json, OptionOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleLazyOfString() {
        var src0 = "A";
        Lazy<String> src = Lazy.of(() -> src0);
        var json = MAPPER.writeValueAsString(new LazyOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":\"A\"}");
        LazyOfString restored = MAPPER.readValue(json, LazyOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleLazyOfTuple() {
        var src00 = "A";
        var src01 = "B";
        Tuple2<String, String> src0 = Tuple.of(src00, src01);
        Lazy<Tuple2<String, String>> src = Lazy.of(() -> src0);
        var json = MAPPER.writeValueAsString(new LazyOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"A\",\"B\"]}");
        LazyOfTuple restored = MAPPER.readValue(json, LazyOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleLeftEitherOfString() {
        var srcl = "A";
        Either<String, Object> src = Either.left(srcl);
        var json = MAPPER.writeValueAsString(new LeftEitherOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"left\",\"A\"]}");
        LeftEitherOfString restored = MAPPER.readValue(json, LeftEitherOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleLeftEitherOfTuple() {
        var srcl0 = "A";
        var srcl1 = "B";
        Tuple2<String, String> srcl = Tuple.of(srcl0, srcl1);
        Either<Tuple2<String, String>, Object> src = Either.left(srcl);
        var json = MAPPER.writeValueAsString(new LeftEitherOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"left\",[\"A\",\"B\"]]}");
        LeftEitherOfTuple restored = MAPPER.readValue(json, LeftEitherOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleRightEitherOfString() {
        var srcr = "A";
        Either<Object, String> src = Either.right(srcr);
        var json = MAPPER.writeValueAsString(new RightEitherOfString().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"right\",\"A\"]}");
        RightEitherOfString restored = MAPPER.readValue(json, RightEitherOfString.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    @Test
    void shouldHandleRightEitherOfTuple() {
        var srcr0 = "A";
        var srcr1 = "B";
        Tuple2<String, String> srcr = Tuple.of(srcr0, srcr1);
        Either<Object, Tuple2<String, String>> src = Either.right(srcr);
        var json = MAPPER.writeValueAsString(new RightEitherOfTuple().setValue(src));
        Assertions.assertThat(json).isEqualTo("{\"value\":[\"right\",[\"A\",\"B\"]]}");
        RightEitherOfTuple restored = MAPPER.readValue(json, RightEitherOfTuple.class);
        Assertions.assertThat(restored.getValue()).isEqualTo(src);
    }

    public static class Tuple1OfString {
        private Tuple1<String> v;

        public Tuple1<String> getValue() {
            return v;
        }

        public Tuple1OfString setValue(Tuple1<String> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple1OfTuple {
        private Tuple1<Tuple1<String>> v;

        public Tuple1<Tuple1<String>> getValue() {
            return v;
        }

        public Tuple1OfTuple setValue(Tuple1<Tuple1<String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple2OfString {
        private Tuple2<String, String> v;

        public Tuple2<String, String> getValue() {
            return v;
        }

        public Tuple2OfString setValue(Tuple2<String, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple2OfTuple {
        private Tuple2<String, Tuple2<String, String>> v;

        public Tuple2<String, Tuple2<String, String>> getValue() {
            return v;
        }

        public Tuple2OfTuple setValue(Tuple2<String, Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple3OfString {
        private Tuple3<String, String, String> v;

        public Tuple3<String, String, String> getValue() {
            return v;
        }

        public Tuple3OfString setValue(Tuple3<String, String, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple3OfTuple {
        private Tuple3<String, Tuple2<String, String>, Tuple2<String, String>> v;

        public Tuple3<String, Tuple2<String, String>, Tuple2<String, String>> getValue() {
            return v;
        }

        public Tuple3OfTuple setValue(
                Tuple3<String, Tuple2<String, String>, Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple4OfString {
        private Tuple4<String, String, String, String> v;

        public Tuple4<String, String, String, String> getValue() {
            return v;
        }

        public Tuple4OfString setValue(Tuple4<String, String, String, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple4OfTuple {
        private Tuple4<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>> v;

        public Tuple4<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>> getValue(
                ) {
            return v;
        }

        public Tuple4OfTuple setValue(
                Tuple4<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple5OfString {
        private Tuple5<String, String, String, String, String> v;

        public Tuple5<String, String, String, String, String> getValue() {
            return v;
        }

        public Tuple5OfString setValue(Tuple5<String, String, String, String, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple5OfTuple {
        private Tuple5<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String> v;

        public Tuple5<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String> getValue(
                ) {
            return v;
        }

        public Tuple5OfTuple setValue(
                Tuple5<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple6OfString {
        private Tuple6<String, String, String, String, String, String> v;

        public Tuple6<String, String, String, String, String, String> getValue() {
            return v;
        }

        public Tuple6OfString setValue(Tuple6<String, String, String, String, String, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple6OfTuple {
        private Tuple6<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String, Tuple2<String, String>> v;

        public Tuple6<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String, Tuple2<String, String>> getValue(
                ) {
            return v;
        }

        public Tuple6OfTuple setValue(
                Tuple6<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String, Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple7OfString {
        private Tuple7<String, String, String, String, String, String, String> v;

        public Tuple7<String, String, String, String, String, String, String> getValue() {
            return v;
        }

        public Tuple7OfString setValue(
                Tuple7<String, String, String, String, String, String, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple7OfTuple {
        private Tuple7<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String, Tuple2<String, String>, Tuple2<String, String>> v;

        public Tuple7<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String, Tuple2<String, String>, Tuple2<String, String>> getValue(
                ) {
            return v;
        }

        public Tuple7OfTuple setValue(
                Tuple7<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String, Tuple2<String, String>, Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple8OfString {
        private Tuple8<String, String, String, String, String, String, String, String> v;

        public Tuple8<String, String, String, String, String, String, String, String> getValue() {
            return v;
        }

        public Tuple8OfString setValue(
                Tuple8<String, String, String, String, String, String, String, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class Tuple8OfTuple {
        private Tuple8<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>> v;

        public Tuple8<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>> getValue(
                ) {
            return v;
        }

        public Tuple8OfTuple setValue(
                Tuple8<String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>, String, Tuple2<String, String>, Tuple2<String, String>, Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class ArrayOfString {
        private Array<String> v;

        public Array<String> getValue() {
            return v;
        }

        public ArrayOfString setValue(Array<String> v) {
            this.v = v;
            return this;
        }
    }

    public static class ArrayOfTuple {
        private Array<Tuple2<String, String>> v;

        public Array<Tuple2<String, String>> getValue() {
            return v;
        }

        public ArrayOfTuple setValue(Array<Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class ListOfString {
        private List<String> v;

        public List<String> getValue() {
            return v;
        }

        public ListOfString setValue(List<String> v) {
            this.v = v;
            return this;
        }
    }

    public static class ListOfTuple {
        private List<Tuple2<String, String>> v;

        public List<Tuple2<String, String>> getValue() {
            return v;
        }

        public ListOfTuple setValue(List<Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class QueueOfString {
        private Queue<String> v;

        public Queue<String> getValue() {
            return v;
        }

        public QueueOfString setValue(Queue<String> v) {
            this.v = v;
            return this;
        }
    }

    public static class QueueOfTuple {
        private Queue<Tuple2<String, String>> v;

        public Queue<Tuple2<String, String>> getValue() {
            return v;
        }

        public QueueOfTuple setValue(Queue<Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class StreamOfString {
        private Stream<String> v;

        public Stream<String> getValue() {
            return v;
        }

        public StreamOfString setValue(Stream<String> v) {
            this.v = v;
            return this;
        }
    }

    public static class StreamOfTuple {
        private Stream<Tuple2<String, String>> v;

        public Stream<Tuple2<String, String>> getValue() {
            return v;
        }

        public StreamOfTuple setValue(Stream<Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class VectorOfString {
        private Vector<String> v;

        public Vector<String> getValue() {
            return v;
        }

        public VectorOfString setValue(Vector<String> v) {
            this.v = v;
            return this;
        }
    }

    public static class VectorOfTuple {
        private Vector<Tuple2<String, String>> v;

        public Vector<Tuple2<String, String>> getValue() {
            return v;
        }

        public VectorOfTuple setValue(Vector<Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class PriorityQueueOfString {
        private PriorityQueue<String> v;

        public PriorityQueue<String> getValue() {
            return v;
        }

        public PriorityQueueOfString setValue(PriorityQueue<String> v) {
            this.v = v;
            return this;
        }
    }

    public static class HashSetOfString {
        private HashSet<String> v;

        public HashSet<String> getValue() {
            return v;
        }

        public HashSetOfString setValue(HashSet<String> v) {
            this.v = v;
            return this;
        }
    }

    public static class HashSetOfTuple {
        private HashSet<Tuple2<String, String>> v;

        public HashSet<Tuple2<String, String>> getValue() {
            return v;
        }

        public HashSetOfTuple setValue(HashSet<Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class LinkedHashSetOfString {
        private LinkedHashSet<String> v;

        public LinkedHashSet<String> getValue() {
            return v;
        }

        public LinkedHashSetOfString setValue(LinkedHashSet<String> v) {
            this.v = v;
            return this;
        }
    }

    public static class LinkedHashSetOfTuple {
        private LinkedHashSet<Tuple2<String, String>> v;

        public LinkedHashSet<Tuple2<String, String>> getValue() {
            return v;
        }

        public LinkedHashSetOfTuple setValue(LinkedHashSet<Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class TreeSetOfString {
        private TreeSet<String> v;

        public TreeSet<String> getValue() {
            return v;
        }

        public TreeSetOfString setValue(TreeSet<String> v) {
            this.v = v;
            return this;
        }
    }

    public static class HashMapOfString {
        private HashMap<Integer, String> v;

        public HashMap<Integer, String> getValue() {
            return v;
        }

        public HashMapOfString setValue(HashMap<Integer, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class HashMapOfTuple {
        private HashMap<Integer, Tuple2<String, String>> v;

        public HashMap<Integer, Tuple2<String, String>> getValue() {
            return v;
        }

        public HashMapOfTuple setValue(HashMap<Integer, Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class LinkedHashMapOfString {
        private LinkedHashMap<Integer, String> v;

        public LinkedHashMap<Integer, String> getValue() {
            return v;
        }

        public LinkedHashMapOfString setValue(LinkedHashMap<Integer, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class LinkedHashMapOfTuple {
        private LinkedHashMap<Integer, Tuple2<String, String>> v;

        public LinkedHashMap<Integer, Tuple2<String, String>> getValue() {
            return v;
        }

        public LinkedHashMapOfTuple setValue(LinkedHashMap<Integer, Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class TreeMapOfString {
        private TreeMap<Integer, String> v;

        public TreeMap<Integer, String> getValue() {
            return v;
        }

        public TreeMapOfString setValue(TreeMap<Integer, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class TreeMapOfTuple {
        private TreeMap<Integer, Tuple2<String, String>> v;

        public TreeMap<Integer, Tuple2<String, String>> getValue() {
            return v;
        }

        public TreeMapOfTuple setValue(TreeMap<Integer, Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class HashMultimapOfSeqString {
        private HashMultimap<String, String> v;

        public HashMultimap<String, String> getValue() {
            return v;
        }

        public HashMultimapOfSeqString setValue(HashMultimap<String, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class HashMultimapOfSeqTuple {
        private HashMultimap<String, Tuple2<String, String>> v;

        public HashMultimap<String, Tuple2<String, String>> getValue() {
            return v;
        }

        public HashMultimapOfSeqTuple setValue(HashMultimap<String, Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class LinkedHashMultimapOfSeqString {
        private LinkedHashMultimap<String, String> v;

        public LinkedHashMultimap<String, String> getValue() {
            return v;
        }

        public LinkedHashMultimapOfSeqString setValue(LinkedHashMultimap<String, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class LinkedHashMultimapOfSeqTuple {
        private LinkedHashMultimap<String, Tuple2<String, String>> v;

        public LinkedHashMultimap<String, Tuple2<String, String>> getValue() {
            return v;
        }

        public LinkedHashMultimapOfSeqTuple setValue(
                LinkedHashMultimap<String, Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class TreeMultimapOfSeqString {
        private TreeMultimap<String, String> v;

        public TreeMultimap<String, String> getValue() {
            return v;
        }

        public TreeMultimapOfSeqString setValue(TreeMultimap<String, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class TreeMultimapOfSeqTuple {
        private TreeMultimap<String, Tuple2<String, String>> v;

        public TreeMultimap<String, Tuple2<String, String>> getValue() {
            return v;
        }

        public TreeMultimapOfSeqTuple setValue(TreeMultimap<String, Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class OptionOfString {
        private Option<String> v;

        public Option<String> getValue() {
            return v;
        }

        public OptionOfString setValue(Option<String> v) {
            this.v = v;
            return this;
        }
    }

    public static class OptionOfTuple {
        private Option<Tuple2<String, String>> v;

        public Option<Tuple2<String, String>> getValue() {
            return v;
        }

        public OptionOfTuple setValue(Option<Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class LazyOfString {
        private Lazy<String> v;

        public Lazy<String> getValue() {
            return v;
        }

        public LazyOfString setValue(Lazy<String> v) {
            this.v = v;
            return this;
        }
    }

    public static class LazyOfTuple {
        private Lazy<Tuple2<String, String>> v;

        public Lazy<Tuple2<String, String>> getValue() {
            return v;
        }

        public LazyOfTuple setValue(Lazy<Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }

    public static class LeftEitherOfString {
        private Either<String, Object> v;

        public Either<String, Object> getValue() {
            return v;
        }

        public LeftEitherOfString setValue(Either<String, Object> v) {
            this.v = v;
            return this;
        }
    }

    public static class LeftEitherOfTuple {
        private Either<Tuple2<String, String>, Object> v;

        public Either<Tuple2<String, String>, Object> getValue() {
            return v;
        }

        public LeftEitherOfTuple setValue(Either<Tuple2<String, String>, Object> v) {
            this.v = v;
            return this;
        }
    }

    public static class RightEitherOfString {
        private Either<Object, String> v;

        public Either<Object, String> getValue() {
            return v;
        }

        public RightEitherOfString setValue(Either<Object, String> v) {
            this.v = v;
            return this;
        }
    }

    public static class RightEitherOfTuple {
        private Either<Object, Tuple2<String, String>> v;

        public Either<Object, Tuple2<String, String>> getValue() {
            return v;
        }

        public RightEitherOfTuple setValue(Either<Object, Tuple2<String, String>> v) {
            this.v = v;
            return this;
        }
    }
}
